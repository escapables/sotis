#!/usr/bin/env python3
"""Validate docs structure and metadata."""

from __future__ import annotations

import re
import os
import sys
from pathlib import Path

DOCS_DIR = Path("docs")
README_PATH = DOCS_DIR / "README.md"
TODO_PATH = DOCS_DIR / "TODO.md"
EXCLUDED_DIRS = {"archive", "research"}
SUMMARY_PATTERN = re.compile(r"^summary:\s*(.+)$", re.MULTILINE)
READ_WHEN_HEADER_PATTERN = re.compile(r"^read_when:\s*$", re.MULTILINE)
READ_WHEN_INLINE_PATTERN = re.compile(r"^read_when:\s*\[(.+?)\]\s*$", re.MULTILINE)
README_DOC_REF_PATTERN = re.compile(r"`(docs/[A-Za-z0-9_.\-/]+\.md)`")
TODO_SECTION_PATTERN = re.compile(r"^###\s+(DONE\s+)?(\d+)\.\s+(.+?)\s*$")
STRICT_FRONT_MATTER = os.environ.get("STRICT_DOCS_FRONT_MATTER", "0") == "1"


def _iter_docs_markdown() -> list[Path]:
    files: list[Path] = []
    for path in DOCS_DIR.rglob("*.md"):
        rel = path.relative_to(DOCS_DIR)
        parts = rel.parts
        if any(part.startswith(".") for part in parts):
            continue
        if any(part in EXCLUDED_DIRS for part in parts):
            continue
        files.append(path)
    return sorted(files)


def _split_front_matter(content: str) -> tuple[str | None, str]:
    if not content.startswith("---\n"):
        return None, content
    rest = content[4:]
    marker = "\n---\n"
    end_idx = rest.find(marker)
    if end_idx == -1:
        return None, content
    return rest[:end_idx], rest[end_idx + len(marker) :]


def _extract_read_when(front_matter: str) -> list[str]:
    hints: list[str] = []

    header_match = READ_WHEN_HEADER_PATTERN.search(front_matter)
    if header_match is not None:
        for line in front_matter[header_match.end() :].splitlines():
            stripped = line.strip()
            if stripped.startswith("- "):
                hint = stripped[2:].strip()
                if hint:
                    hints.append(hint)
                continue
            if stripped:
                break

    inline_match = READ_WHEN_INLINE_PATTERN.search(front_matter)
    if inline_match is not None:
        for item in inline_match.group(1).split(","):
            hint = item.strip().strip("'\"")
            if hint:
                hints.append(hint)

    deduped: list[str] = []
    seen: set[str] = set()
    for hint in hints:
        if hint in seen:
            continue
        seen.add(hint)
        deduped.append(hint)
    return deduped


def _has_heading(body: str) -> bool:
    for line in body.splitlines():
        stripped = line.strip()
        if not stripped:
            continue
        # Skip maintainer-only notes that appear before the heading
        if stripped.startswith("> **MAINTAINER-ONLY"):
            continue
        return stripped.startswith("#")
    return False


def _validate_doc(path: Path) -> tuple[list[str], list[str]]:
    errors: list[str] = []
    warnings: list[str] = []
    content = path.read_text(encoding="utf-8")
    if not content.strip():
        return ["empty file"], warnings

    front_matter, body = _split_front_matter(content)

    if not _has_heading(body):
        warnings.append("missing markdown heading")

    if front_matter is None:
        msg = "missing front matter"
        if STRICT_FRONT_MATTER:
            errors.append(msg)
        else:
            warnings.append(msg)
        return errors, warnings

    summary_match = SUMMARY_PATTERN.search(front_matter)
    if summary_match is None:
        errors.append("missing summary")
    elif not summary_match.group(1).strip().strip("'\""):
        errors.append("empty summary")

    read_when = _extract_read_when(front_matter)
    if not read_when:
        errors.append("missing or empty read_when")

    return errors, warnings


def _validate_docs_index(files: list[Path]) -> list[str]:
    if not README_PATH.exists():
        return ["missing docs/README.md"]

    content = README_PATH.read_text(encoding="utf-8")
    refs = set(README_DOC_REF_PATTERN.findall(content))
    if not refs:
        return ["docs/README.md has no `docs/*.md` references"]

    actual = {
        f"docs/{path.relative_to(DOCS_DIR).as_posix()}"
        for path in files
        if path.name != "README.md"
    }

    unknown = sorted(refs - actual)
    missing = sorted(actual - refs)

    errors: list[str] = []
    if unknown:
        errors.append(f"docs/README.md references unknown docs: {', '.join(unknown)}")
    if missing:
        errors.append(f"docs/README.md missing docs: {', '.join(missing)}")
    return errors


def _validate_todo_format(path: Path) -> list[str]:
    errors: list[str] = []
    content = path.read_text(encoding="utf-8")
    _, body = _split_front_matter(content)
    lines = body.splitlines()

    # Skip maintainer-only notes that appear before the heading
    first_non_empty = ""
    for line in lines:
        stripped = line.strip()
        if not stripped:
            continue
        if stripped.startswith("> **MAINTAINER-ONLY"):
            # Skip all lines in the blockquote until we hit a non-blockquote line
            continue
        if stripped.startswith("> "):
            continue
        first_non_empty = stripped
        break
    
    if first_non_empty != "# TODO":
        errors.append('TODO.md must start with heading "# TODO"')

    if re.search(r"^##\s+Status Snapshot", body, re.MULTILINE):
        errors.append("TODO.md must not contain Status Snapshot section (use HANDOFF.md)")

    sections: list[tuple[int, int, bool, str]] = []
    for idx, line in enumerate(lines):
        stripped = line.strip()
        match = TODO_SECTION_PATTERN.match(stripped)
        if not match:
            continue
        is_done = match.group(1) is not None
        sections.append((idx, int(match.group(2)), is_done, match.group(3).strip()))

    if not sections:
        return errors + ["TODO.md requires numbered sections like `### 1. Title`"]

    expected = 1
    for _, number, _, title in sections:
        if number != expected:
            errors.append(f"TODO.md section numbering must be sequential; expected {expected}, got {number}")
            expected = number + 1
        else:
            expected += 1
        title_words = re.findall(r"[A-Za-z0-9][A-Za-z0-9+:/-]*", title)
        if not 2 <= len(title_words) <= 4:
            errors.append(
                f"TODO section {number} title must contain 2-4 words; got {len(title_words)} (`{title}`)"
            )

    for i, (start_idx, section_number, is_done, _) in enumerate(sections):
        end_idx = sections[i + 1][0] if i + 1 < len(sections) else len(lines)
        raw_block = lines[start_idx + 1 : end_idx]
        block: list[str] = []
        for raw_line in raw_block:
            stripped = raw_line.strip()
            if is_done and stripped:
                if not raw_line.startswith("#"):
                    errors.append(
                        f"TODO section {section_number} marked DONE must prefix all non-empty lines with '#'")
                    break
                stripped = raw_line[1:].strip()
            block.append(stripped)

        task_idx = scope_idx = done_idx = None
        for rel_idx, line in enumerate(block):
            if line.startswith("Task:") and task_idx is None:
                task_idx = rel_idx
            elif line == "Scope:" and scope_idx is None:
                scope_idx = rel_idx
            elif line == "Done when:" and done_idx is None:
                done_idx = rel_idx

        if task_idx is None:
            errors.append(f"TODO section {section_number} missing `Task:`")
            continue
        if scope_idx is None:
            errors.append(f"TODO section {section_number} missing `Scope:`")
            continue
        if done_idx is None:
            errors.append(f"TODO section {section_number} missing `Done when:`")
            continue
        if not (task_idx < scope_idx < done_idx):
            errors.append(f"TODO section {section_number} must order fields as Task -> Scope -> Done when")
            continue

        task_text = block[task_idx][len("Task:") :].strip()
        if not task_text:
            errors.append(f"TODO section {section_number} `Task:` must include a sentence")
        elif task_text[-1] not in ".!?":
            errors.append(f"TODO section {section_number} `Task:` must end with sentence punctuation")
        elif len(re.findall(r"[.!?]", task_text)) != 1:
            errors.append(f"TODO section {section_number} `Task:` must be exactly one sentence")

        scope_lines = block[scope_idx + 1 : done_idx]
        done_lines = block[done_idx + 1 :]
        scope_bullets = [line for line in scope_lines if line.strip().startswith("- ")]
        done_bullets = [line for line in done_lines if line.strip().startswith("- ")]

        if any(line.strip() and not line.strip().startswith("- ") for line in scope_lines):
            errors.append(f"TODO section {section_number} Scope block must contain only dash bullets")
        if any(line.strip() and not line.strip().startswith("- ") for line in done_lines):
            errors.append(f"TODO section {section_number} Done when block must contain only dash bullets")

        if not 2 <= len(scope_bullets) <= 5:
            errors.append(f"TODO section {section_number} Scope block requires 2-5 bullets")
        if not done_bullets:
            errors.append(f"TODO section {section_number} Done when block requires at least one bullet")

    return errors


def main() -> int:
    if not DOCS_DIR.exists():
        print("[docs] no docs/ directory")
        return 0

    docs_files = _iter_docs_markdown()
    if not docs_files:
        print("[docs] no markdown files")
        return 0

    failed = False
    warned = False

    print("[docs] validating markdown")
    for path in docs_files:
        rel = path.relative_to(DOCS_DIR).as_posix()
        errors, warnings = _validate_doc(path)
        if path == TODO_PATH:
            errors.extend(_validate_todo_format(path))
        if errors:
            failed = True
            print(f"  FAIL {rel}: {', '.join(errors)}")
        elif warnings:
            warned = True
            print(f"  WARN {rel}: {', '.join(warnings)}")
        else:
            print(f"  OK   {rel}")

    index_errors = _validate_docs_index(docs_files)
    if index_errors:
        failed = True
        print("[docs] index checks")
        for err in index_errors:
            print(f"  FAIL {err}")
    else:
        print("[docs] index checks OK")

    if failed:
        print("[docs] validation failed")
        return 1
    if warned:
        print("[docs] validation passed with warnings")
    else:
        print("[docs] validation passed")
    return 0


if __name__ == "__main__":
    sys.exit(main())
